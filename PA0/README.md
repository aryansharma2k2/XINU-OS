## Tasks

Implemented several XINU functions that perform the following tasks:

1. `long zfunction(long param)`

    This function performs a number of operations on the parameter `param` and then returns it. These operations are:
    - Clear the 20th to 27th bits, counting from the left starting with 0.
    - Shift by 8 bits to the left.
    - Fill the right-most 8 bits with 1s.
    
    For example, the input parameter `0xaabbccdd` should generate a return value of `0xbbc00dff`. You can assume that the size of long is 4 bytes. **The code for this function must be entirely written in x86 assembly**. Behavior implemented in a C file will not be accepted. You should not use inline assembly, (i.e., do not use asm(???)). To investigate the assembly code generated by the compiler, you can use the tool `objdump -d <___.o>` to disassemble an object file. The object files reside in the [compile](compile) directory within the main Xinu directory. You can also see some of the *.S files in the [sys](sys) directory for reference. You are free to write a C file of the behavior to get familiar with the behavior and generating assembly, but ensure that you do not submit a C file and that your header file links to the assembly file.

   To ensure that the assembly file behaves properly, you must ensure that it is a *.S file (capital S) rather than a *.s file (lowercase S). Additionally, if you use objdump, you must ensure that you do it on same type of machine that Xinu will be running on because assembly is not portable. In this case, make sure you do all of this on the XINU+QEMU VCL VM.

2. `void printprocstks(int priority)`

    For each existing process (i.e., non-free processes) with larger priority than the parameter, print the stack base, stack size, stacklimit, and stack pointer. Also, for each of these processes, include the process name, the process id and the process priority.

    To help you do this, please look into [h/proc.h](h/proc.h). Note the `proctab[]` array that holds all processes. Also, note that the `pesp` member of the `pentry` structure holds the saved stack pointer. Therefore, the currently executing process has a stack pointer that is different from the value of this variable. In order to help you get the stack pointer of the currently executing process, carefully study the [sys/stacktrace.c](sys/stacktrace.c) file. The register `%esp` holds the current stack pointer. You can use in-line assembly(i.e., `asm("...")`) to do this part.

3. `void printsyscallsummary()`

    Print the summary of the system calls which have been invoked for each process. This task is loosely based on the functionality of [LTTng](http://lttng.org/). There are 43 system calls declared. Please look into [h/kernel.h](h/kernel.h) to see all declared system calls. However, only 27 system calls are implemented in this XINU version. You will need to trace these system calls:    
    ```c    
    SYSCALL	freemem(struct mblock *block, unsigned size);
    SYSCALL chprio(int pid, int newprio);
    SYSCALL getpid();
    SYSCALL getprio(int pid);
    SYSCALL	gettime(long *timvar);
    SYSCALL kill(int pid);
    SYSCALL	receive();
    SYSCALL	recvclr();
    SYSCALL	recvtim(int maxwait);
    SYSCALL resume(int pid);
    SYSCALL scount(int sem);
    SYSCALL sdelete(int sem);
    SYSCALL	send(int pid, WORD msg);
    SYSCALL	setdev(int pid, int dev1, int dev2);
    SYSCALL	setnok(int nok, int pid);
    SYSCALL screate(int count);
    SYSCALL signal(int sem);
    SYSCALL signaln(int sem, int count);
    SYSCALL	sleep(int n);
    SYSCALL	sleep10(int n);
    SYSCALL sleep100(int n);
    SYSCALL sleep1000(int n);
    SYSCALL sreset(int sem, int count);
    SYSCALL stacktrace(int pid);
    SYSCALL	suspend(int pid);
    SYSCALL	unsleep(int pid);
    SYSCALL	wait(int sem);
    ```
    The implementation of these 27 system calls are in the [sys](sys) directory. You are asked to print the frequency (how many times each system call type is invoked) and the average execution time (how long it takes to execute each system call type on average) of these 27 system calls for each process. In order to do this, you will need to modify the implementation of these 27 types of system calls to trace them whenever they are invoked. To measure the time, XINU provides a global variable named `ctr1000` to track the time (in milliseconds) passed by since the system starts. Please look into [sys/clkinit.c](sys/clkinit.c) and [sys/clkint.S](sys/clkint.S) to see the details.

    The output of this function should group the system calls by the process that called them. See the sample output further down in the readme for an example of this. It must also display recorded information all processes that were active during the tracing period, including processes that terminated prior to calling printsyscallsummary.

    Also implemented two other functions:

    - `void syscallsummary_start()`: to start tracing the system calls. This function first clears all statistical numbers. All the system calls are invoked after calling this function (and before calling `syscallsummary_stop()`) will be presented in the system call summary.

    - `void syscallsummary_stop()`: to stop tracing the system calls. 
    
    In other words, these two functions determine the duration in which the system calls are traced.

    A sample main file is given to verify:
    ```c
    /* test.c - main */

    #include <conf.h>
    #include <kernel.h>
    #include <proc.h>
    #include <stdio.h>
    #include <lab0.h>

    int prX;
    void halt();

    /*------------------------------------------------------------------------
    *  main  --  user main program
    *------------------------------------------------------------------------
    */
    void prch(char c)
    {
        int i;
        sleep(5);	
    }
    int main()
    {
        kprintf("Task 1 (zfunction)\n");
        kprintf("0xaabbccdd => %d\n", zfunction(0xaabbccdd));

        kprintf("Task 2 (printprocstks)\n");
        printprocstks(10);
    
        kprintf("Task 3 (printsyscallsummary)\n");
        syscallsummary_start();        
        resume(prX = create(prch,2000,20,"proc X",1,'A'));
        sleep(10);
        syscallsummary_stop();
        printsyscallsummary();
        return 0;
    }
    ```